/*
 ============================================================================
 Name        : day_2_part2.c
 Author      : PS
 Date		 : 5.27.20
 Version     : 1
 Copyright   : N/A
 Description : Day 2: 1202 Program Alarm

				 To complete the gravity assist, you need to determine what
				 pair of inputs produces the output 19690720.

				 The inputs should still be provided to the program by replacing
				 the values at addresses 1 and 2, just like before. In this
				 program, the value placed in address 1 is called the noun,
				 and the value placed in address 2 is called the verb. Each
				 of the two input values will be between 0 and 99, inclusive.

				 Once the program has halted, its output is available at
				 address 0, also just like before. Each time you try a pair of
				 inputs, make sure you first reset the computer's memory to the
				 values in the program (your puzzle input) - in other words,
				 don't reuse memory from a previous attempt.

				 Find the input noun and verb that cause the program to produce
				 the output 19690720. What is 100 * noun + verb? (For example, if
				 noun=12 and verb=2, the answer would be 1202.)

 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#define 	IN_FILENAME		"gravity_assist_program.txt"
//#define 	IN_FILENAME		"test.txt"
#define		OUT_FILENAME	"solution.txt"
#define		UNKNOWN_SIZE	1000
#define		TARGET			19690720
#define		STEP			4		// step 4 positions after OPCODE
#define		INPUT1			1		// input1 value position
#define		INPUT2			2		// input2 value position
#define		OUTPUT			3		// output value position
#define		ADD				1		// opcode 1
#define		MUL				2		// opcode 2
#define		HALT			99		// opcode 99

uint32_t Intcode(int8_t noun, int8_t verb, int32_t array_size,
		volatile uint32_t program[]);
void resetProgram(volatile uint32_t original[], volatile uint32_t copy[],
		int32_t array_size);
void header(char *c);

int main(void) {

	/*
	 * open i/o files
	 */

	FILE *input_fp, *output_fp;
	input_fp = fopen(IN_FILENAME, "r");
	output_fp = fopen(OUT_FILENAME, "w");

	// error check
	if (input_fp == NULL || output_fp == NULL) {
		printf("Error opening i/o files\n");
		exit(EXIT_FAILURE);
	}

	/*
	 * initialize program array and opcodes
	 */

	volatile uint32_t program[UNKNOWN_SIZE];
	volatile uint32_t programBackup[UNKNOWN_SIZE];
	volatile uint32_t opcode = 0;

	/*
	 * load opcodes into program arrays (live copy and backup)
	 */

	volatile uint16_t i;
	for (i = 0; (fscanf(input_fp, "%d,", &opcode) != EOF); i++) {
		program[i] = opcode;
	}
	uint16_t len = i;

	for (i = 0; i < len; i++)
		programBackup[i] = program[i];

	/*
	 * print header
	 */

	printf("INTCODE Solutions");
	printf("\n\n*********************************************\n");
	printf("Item\t\tNoun\t\tVerb\t\tOutput\n");

	fprintf(output_fp, "INTCODE Solutions");
	fprintf(output_fp, "\n\n*********************************************\n");
	fprintf(output_fp, "Item\t\tNoun\t\tVerb\t\tOutput\n");

	int32_t item = 1;
	int8_t noun;
	int8_t verb;
	int32_t value;

	for (int8_t j = 0; j < 100; j++) {
		for (int8_t k = 0; k < 100; k++) {
			resetProgram(program, programBackup, len);	// reinitialize program
			value = Intcode(j, k, len, program);			// get output value
			if (value == TARGET) {
				noun = j;
				verb = k;
			}
			printf("%d\t\t%d\t\t%d\t\t%d\n", item, j, k, value);
			fprintf(output_fp, "%d\t\t\t%d\t\t\t%d\t\t\t%d\n", item, j, k, value);
			item++;
		}
	}

	printf("\nOutput Target %d is generated by using noun = %d and verb = %d\n",
			TARGET, noun, verb);
	printf("PUZZLE ANSWER: 100 * noun + verb = %d", 100 * noun + verb);
	fprintf(output_fp,
			"\nOutput Target %d is generated by using noun = %d and verb = %d\n",
			TARGET, noun, verb);
	fprintf(output_fp, "PUZZLE ANSWER: 100 * noun + verb = %d",
			100 * noun + verb);

	fclose(input_fp);  // close files
	fclose(output_fp);

	return EXIT_SUCCESS;  //test
}

uint32_t Intcode(int8_t noun, int8_t verb, int32_t array_size,
		volatile uint32_t program[]) {

	program[1] = noun;
	program[2] = verb;

	uint32_t addr1;
	uint32_t addr2;
	uint32_t addr3;

	for (uint32_t i = 0; i < array_size; i += 4) {
		switch (program[i]) {
		case ADD:
			addr1 = program[i + INPUT1];
			addr2 = program[i + INPUT2];
			addr3 = program[i + OUTPUT];
			program[addr3] = program[addr1] + program[addr2];
			break;

		case MUL:
			addr1 = program[i + INPUT1];
			addr2 = program[i + INPUT2];
			addr3 = program[i + OUTPUT];
			program[addr3] = program[addr1] * program[addr2];
			break;

		case HALT:

			return program[0];
			break;

		default:
			break;

		}

	}
	return program[0];
}

void resetProgram(volatile uint32_t original[], volatile uint32_t copy[],
		int32_t array_size) {
	for (int i = 0; i < array_size; i++)
		original[i] = copy[i];
}

void header(char *c) {
	puts("\n\n*********************************************\n");
	fprintf(fopen(OUT_FILENAME, "a"),
			"\n\n*********************************************\n");
	printf("Program %s\n", c);
	fprintf(fopen(OUT_FILENAME, "a"), "Program %s\n", c);
}

